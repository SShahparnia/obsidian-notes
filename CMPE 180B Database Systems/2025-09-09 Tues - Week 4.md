
## Outline

- Features of Good Relational Design

- Functional Dependencies

- Decomposition Using Functional Dependencies

- Normal Forms

- Functional Dependency Theory

- Algorithms for Decomposition

- Multivalued Dependencies

- Atomic Domains & 1NF

- Database-Design Process

- Modeling Temporal Data

  

---

  

## Features of Good Relational Design

- Example: combining **instructor** and **department** into `in_dep` (natural join).

- Leads to **repetition** of info.

- Requires **NULL values** when new departments are added without instructors.

  

---

  

## Decomposition

- To fix repetition, decompose into two schemas: `instructor` and `department`.

- **Not all decompositions are good**.

- Example: Splitting `employee(ID, name, street, city, salary)` into

- `employee1(ID, name)`

- `employee2(name, street, city, salary)`

- Problem: if two employees share the same name → **lossy decomposition**.

  

---

  

## Lossless vs Lossy Decomposition

- **Definition**:

- A decomposition $R \to (R_1, R_2)$ is **lossless** if:

$$ \pi_{R_1}(r) \bowtie \pi_{R_2}(r) = r $$

- Otherwise it is **lossy** if:

$$ \pi_{R_1}(r) \times \pi_{R_2}(r) \neq r $$

  

- **Example**:

- $R = (A, B, C)$

- $R_1 = (A, B)$, $R_2 = (B, C)$

- Decomposition is **lossless** since $B \to \{B, C\}$.

  

---

  

## Normalization Theory

- Goal: decide if relation $R$ is in “good form”.

- If not, decompose into $\{R_1, R_2, \dots, R_n\}$ such that:

- Each $R_i$ is in good form.

- Decomposition is **lossless**.

- Based on:

- **Functional dependencies (FDs)**

- **Multivalued dependencies (MVDs)**

  

---

  

## Functional Dependencies (FDs)

- Constraints on data integrity.

- Examples in a university DB:

- Each student/instructor uniquely identified by `ID`.

- Each has only one `name`.

- Each department has one `budget` and `building`.

- **Definition**:

- For relation $R$, $\alpha \to \beta$ holds iff:

$$ t_1[\alpha] = t_2[\alpha] \implies t_1[\beta] = t_2[\beta] $$

  

---

  

## Closure of Functional Dependencies

- Given $F$, derive all implied FDs.

- Example: If $A \to B$ and $B \to C$, then $A \to C$.

- Closure denoted as $F^+$.

  

---

  

## Keys & FDs

- **Superkey**: $K$ is a superkey if $K \to R$.

- **Candidate key**: $K$ is minimal superkey (no proper subset determines $R$).

- Example with `in_dep(ID, name, salary, dept_name, building, budget)`:

- Expect: `dept_name → building`, `ID → building`.

- But **not** `dept_name → salary`.

  

---

  

## Trivial FDs

- FD is **trivial** if $\beta \subseteq \alpha$.

- Examples:

- `ID, name → ID`

- `name → name`

  

---

  

## Lossless Decomposition via FDs

- Decomposition of $R$ into $(R_1, R_2)$ is **lossless** if:

- $(R_1 \cap R_2) \to R_1$ or $(R_1 \cap R_2) \to R_2$ is in $F^+$.

  

---

  

## Dependency Preservation

- Checking constraints on updates can be costly.

- A decomposition is **dependency preserving** if FDs can be checked without expensive joins.

- Example: `dept_advisor(s_ID, i_ID, dept_name)` with:

- $i\_ID \to dept\_name$

- $(s\_ID, dept\_name) \to i\_ID$

→ decomposition not dependency preserving.

  

---

  

## Boyce–Codd Normal Form (BCNF)

- A relation $R$ is in BCNF if for all $\alpha \to \beta \in F^+$:

- Either $\beta \subseteq \alpha$ (trivial), or

- $\alpha$ is a **superkey**.

- Ensures no redundancy or anomalies.

  

- **Example**: `in_dep(ID, name, salary, dept_name, building, budget)`

- `dept_name → building, budget` holds.

- But `dept_name` is not a superkey → not BCNF.

- Decompose into `instructor` and `department` tables → both BCNF.

  

---

  

## Third Normal Form (3NF)

- $R$ is in 3NF if for every FD $\alpha \to \beta$:

1. $\beta \subseteq \alpha$ (trivial), or

2. $\alpha$ is a superkey, or

3. Every attribute in $\beta - \alpha$ is part of some **candidate key**.

  

- 3NF is a relaxation of BCNF to ensure **dependency preservation**.

  

- **Example**:

- `dept_advisor(s_ID, i_ID, dept_name)`

- Candidate keys: `{s_ID, dept_name}`, `{s_ID, i_ID}`

- Violates BCNF but satisfies 3NF.

  

---

  

## Redundancy in 3NF

- Example: $R = (J, K, L)$ with $F = \{JK \to L, L \to K\}$.

- Even though in 3NF, may still have:

- Repetition of data.

- Need for NULL values.

  

---

  

## Comparison: BCNF vs 3NF

- **3NF Advantages**:

- Always possible with losslessness and dependency preservation.

- **3NF Disadvantages**:

- May require NULLs.

- May have redundancy.

- **BCNF**: Stricter, avoids redundancy but may lose dependency preservation.

  

---

  

## Higher Normal Forms (Beyond 3NF/BCNF)

- Example: `inst_info` with attributes for instructor, children, and phone numbers.

- Independent multivalued attributes → suggest need for **4NF**.

- Avoids redundancy when independent attributes exist.

  

---

  

## In-Class Example

### Schema

`Student_Course(student_ID, student_name, course_ID, course_name, instructor)`

  

### FDs

- $student\_ID \to student\_name$

- $course\_ID \to course\_name$

- $course\_ID \to instructor$

  

### Tasks

1. Check if schema is in BCNF. If not, decompose.

2. Check if schema is in 3NF. If not, decompose.

3. Explain why decomposition into BCNF/3NF avoids anomalies.

  

---

  

# Key Takeaways

- **Good design** minimizes redundancy, NULLs, and anomalies.

- **Lossless decomposition** is essential to avoid losing info.

- **FDs** are the foundation of normalization.

- **BCNF** ensures stronger rules but may not preserve dependencies.

- **3NF** guarantees dependency preservation but can still allow redundancy.

- Higher forms like **4NF** handle multivalued dependencies.