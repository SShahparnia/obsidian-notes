
## Database Design Phases

1. **Initial Phase – Requirement Analysis**

- Gather user requirements via interviews, surveys, etc.

- Identify **use cases**: queries, updates, reports.

- Understand **business rules**: conditions, constraints, validation.

  

- Determine **entities** and **attributes**:

- Entities: e.g., Customer, Order, Product.

- Attributes: e.g., CustomerID, Name, Address.

  

- Create **preliminary ER diagram** and verify with users.

- Define **constraints**: primary keys, foreign keys, uniqueness, nullability.

  

2. **Second Phase – Choosing a Data Model**

- **Relational Model**: tabular, SQL-based.

- **Hierarchical Model**: tree-structured.

- **Network Model**: graph-structured.

- **Object-Oriented Model**: objects with data + methods.

- **NoSQL Models**: document, key-value, graph for unstructured/semi-structured data.

  

- Factors: nature of data, complexity of relationships, performance needs, flexibility, CAP theorem.

  

3. **Final Phase – Logical & Physical Design**

- Logical design: decide schemas, map ER to chosen model.

- Physical design: storage, data types, indexes, partitioning, clustering.

- Implementation: create schema, apply DDL (CREATE TABLE, etc.), relationships, constraints.

- Testing: functional, performance, backup/recovery.

  

---

  

## Design Alternatives & Approaches

- Avoid pitfalls:

- **Redundancy** → inconsistency.

- **Incompleteness** → missing representation.

  

- Approaches:

- **Entity-Relationship Model (ER)**.

- **Normalization theory** (formal tests for bad design).

  

---

  

## ER Model Basics

- **Entity**: distinguishable object (e.g., person, course).

- **Entity Set**: group of similar entities.

- **Attributes**: properties of entity (ID, name, etc.).

- **Primary Key**: subset of attributes uniquely identifying entity.

  

- **Diagram Representation**:

- Rectangle = entity set.

- Underlined attribute = primary key.

  

---

  

## Relationships

- **Relationship**: association between entities (e.g., student–advisor).

- **Relationship Set**: collection of such associations.

- **Diagram Representation**:

- Diamond = relationship.

- Line connects related entities.

- Attributes can belong to relationships (e.g., advisor has "date").

  

- **Roles**: labels when entity set participates multiple times (e.g., course_id, prereq_id).

  

- **Degree**:

- Binary: between 2 entities (most common).

- Ternary: among 3 entities (e.g., instructor–student–project).

  

---

  

## Attributes

- **Simple** vs **Composite** (e.g., name → first, last).

- **Single-Valued** vs **Multivalued** (e.g., phone_numbers).

- **Derived**: computed (e.g., age from DOB).

- **Domain**: allowed values.

  

- Diagram: curly braces for multivalued, oval for attributes.

  

---

  

## Mapping Cardinality Constraints

- Defines number of associated entities.

- Types:

- One-to-one.

- One-to-many.

- Many-to-one.

- Many-to-many.

  

- Notation: directed line (→) for "one", undirected (—) for "many".

- Participation:

- **Total** (double line): every entity participates.

- **Partial** (single line): optional participation.

  

---

  

## Primary Keys

- For **entity sets**: attributes uniquely identify entity.

- For **relationship sets**: union of participating entities' keys (+ attributes if any).

- Binary relationships:

- M:N → union of keys.

- 1:M or M:1 → key from "many" side.

- 1:1 → either side.

  

---

  

## Weak Entity Sets

- Existence depends on identifying entity.

- Uses **discriminator** + identifying entity key.

- Diagram: double rectangle for weak entity, double diamond for identifying relationship.

- Example: section depends on course.

  

---

  

## Redundancy in Attributes

- E.g., `student.dept_name` duplicates info in `stud_dept` relationship.

- Redundant attributes should be avoided.

  

---

  

## Reduction to Relation Schemas

- Each entity/relationship → relation schema.

- Composite attributes flattened.

- Multivalued attributes → separate table.

- M:N relationships → separate schema with foreign keys.

- Redundant schemas avoided by adding FK into "many" side.

  

---

  

## Extended ER Features

- **Specialization** (top-down): subgroupings inherit parent attributes.

- **Generalization** (bottom-up): combine similar entities.

- **Completeness Constraint**: total vs partial generalization.

- **Aggregation**: treat relationship as abstract entity (relationship among relationships).

  

---

  

## ER Design Issues & Notation

- Common mistakes: confusing entities vs attributes, or entity sets vs relationship sets.

- Symbols: rectangles, diamonds, ovals, lines, ISA triangles.

- Alternatives: Chen notation, Crow’s Foot, UML class diagrams.

- UML: similar to ER but with different syntax.

  

---

  

## In-Class Exercise: University Database

- Entities: Department, Instructor, Course, Student.

- Relationships: instructor–department, instructor–course, student–course.

- Attributes: primary/foreign keys, grades.

- Constraints: cardinalities, total vs partial participation.

  

---

  

## Homework

1. **E-commerce Database** ER design.

2. **ER Design Discussion**: multiple addresses, products without categories.

3. **ER with Weak Entities**: extend university DB with sections as weak entities.

  

---

  

# Key Takeaways

- Database design moves from requirements → conceptual (ER) → logical schema → physical implementation.

- ER diagrams model entities, relationships, attributes, and constraints.

- Good design avoids redundancy and incompleteness.

- Extended ER features (specialization, generalization, aggregation) increase modeling power.

- Always verify designs with stakeholders and test with sample data.