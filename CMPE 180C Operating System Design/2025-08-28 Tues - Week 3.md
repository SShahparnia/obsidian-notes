# Operating System Structures
## Operating System Services
- OS provide an env. for execution of programs and services to programs and users
- One set of OS services provides functions for user:
	- UI
		- Varies between CLI, GUI, Batch
	- Program Execution: 
		- System load program into mem and run the program, end execution, either normally or abnormally
	- I/O Operations:
		- Running programs may require I/O, which may involve a file or device
	- File-System manipulation:
		- Programs need to read/write files and directories, create/delete them, search them, list file info, permission mgmt.
	- Communications
		- Processes may exchange info, on same computer or between computers on a network
		- Comms. may be via shared memory or through message passing (packets moved by the OS)
	- Error Detection
		- May occur in CPU and mem. hardware, in I/O devices, in user program
		- Each type of error requires OS to take appropriate action
		- Debugging facilities can greatly enhance the user's and programmers abilities to use the system (efficiently)
	- Resource Allocation
		- multiple users/jobs running concurrently
		- Resource types: CPU cycles, main memory, file storage, I/O devices
	- Accounting:
		- Keep track of which users use resources (amount and type)
	- Protection and Security
		- Protection: involves ensuring all access is controlled to resources
		- Security to system from outsiders requires user authentication, extends to defending external I/O devices from invalid access attempts
## User Operating System Interface - CLI
- CLI (shell): allows direct command entry 
	- implemented in kernel or by systems program
	- Primarily fetches command from user and executes it
	- Sometimes commands built-in, sometimes just names of programs
		- if the latter, adding new features doesn't require shell modification
## User Operating System Interface - GUI
- User-friendly desktop metaphor interface
	- Usually mouse, keyboard, monitor
	- Icons represent files, programs, actions, etc
- Many systems now include both CLI and GUI interfaces
	- Windows is GUI with CLI "command" shell
	- Apple Mac OS X is "Aqua" GUI interface with UNIX kernel underneath and shells available
	- Unix and Linux have CLI with optional GUI interfaces (CDE, KDE, GNOME)
## System Calls
- Programming interface to the services provided by the OS
- Typically written in high-level (C or C++)
- Mostly accessed by programs via a high-level API (application programming interface)
	- 3 most common API:
		- Win32 for windows
		- POSIX for posix-based systems (includes unix, linux, and mac os x)
		- Java API for JVM (java virtual machine)
## System Call Implementation
- Typically a number associated with each system call
	- System-call interface maintains a table indexed according to these numbers
## System Call Parameter Passing
- More info is required often than identity of desired sys call
	- Exact type and amt. info vary according to OS and call
- 3 general methods used to pass parameters to OS:
	- Pass params. in registers (some situations params > registers)
	- Params stored in a block, table, in memory, and address of block passed as a param in a register
	- Params placed or pushed onto stack by program and popped off stack by OS
	- Block and stack methods do not limit the number or length of params
## Types of System Calls
- Process Control
	- create/terminate process
	- end, abort
	- load, execute
	- get/set process attributes
	- wait for time
	- wait/signal event
	- allocate and free memory
	- Dump memory if error
	- Debugger for determining bugs, single step execution
	- Locks for managing access to shared data between processes
- File Management
	- create/delete file
	- open/close file
	- read, write, reposition
	- get/set file attributes
- Device Management
	- request/release device
	- read, write, reposition
	- get/set device attributes
	- logically attach/detach devices
- Information Maintenance
	- get/set time or date
	- get/set system data
	- get/set process, file, device attributes
- Communications
	- create/delete communication connection
	- send/receive messages if message passing model to host name or process name
		- from client to server
	- shared-memory model create and gain access to memory regions
	- transfer status information
	- attach/detach remote devices
- Protection
	- Control access to resources
	- Get/set permissions
	- Allow and deny user access
## System Programs
- System programs provide a convenient environment for program development and execution. Can be divided into:
	- File manipulation
	- Status information sometimes stores in a file modification
	- programming language support
	- program loading and execution
	- Communications
	- Background services
	- Application programs
- Most users' view of the OS is defined by system programs, not actual system calls
- Provide a convenient environment for program dev and execution
- File Management - create, delete, copy, rename, print, dump, list, and generally manipulate files and directories
- Status info
	- some ask system for info - date, time, amount of memory available, disk space, # users
	- others provided performance, logging, debugging info
	- Some systems implement a registry - used to store and retrieve config info
- File Modification
	- text editors and special commands
- Programming-language support
	- compilers, assemblers, debuggers, and interpreters sometimes provided
- Program loading and execution
	- absolute loaders, relocatable loaders, linkage editors, overlay-loaders, debugging systems for higher level and machine language
- Communications - provide mechanism for creating virtual connections among processes, users, and computer systems
- Background Services
	- launch at boot time
		- some for startup/then terminate
		- some from system boot to shutdown
	- provide facilities like disk checking, process scheduling, error logging, printing
	- run in user context not kernel
	- known as services, subsystems, daemons
- Application programs
	- no pertain to system
	- run by user
	- not part of OS typically
## Operating System Design and Implementation
- Design and implementation of OS not "solvable" but some good approaches
- Goals
	- User - OS should be easy to learn/use, reliable, safe, fast
	- System - OS should be easy to design, implement, and maintain (flexible, reliable, error-free, efficient)
- 